{
	"$schema": "https://raw.githubusercontent.com/martinring/tmlanguage/master/tmlanguage.json",
	"name": "SC",
	"patterns": [
	  {
		"include": "#comments"
	  },
	  {
		"include": "#support"
	  },
	  {
		"include": "#core"
	  }
	],
	"repository": {
	  "comments": {
		"patterns": [
		  {
			"include": "#line_comment"
		  },
		  {
			"include": "#block_comment"
		  }
		]
	  },
	  "line_comment": {
		"patterns": [
		  {
			"match": "(//).*$\\n?",
			"name": "comment.line.double-slash.sc"
		  }
		]
	  },
	  "block_comment": {
		"patterns": [
		  {
			"name": "comment.block.nested.sc",
			"begin": "/\\*",
			"end": "\\*/",
			"patterns": [
			  {
				"include": "#block_comment"
			  }
			]
		  }
		]
	  },
	  "support": {
		"patterns": [
		  {
			"name": "support.type.builtin.sc",
			"match": "\\b(Void|Bool|Int|Float|String)\\b"
		  }
		]
	  },
	  "core": {
		"patterns": [
		  {
			"include": "#literal_number"
		  },
		  {
			"include": "#literal_language_constant"
		  },
		  {
			"include": "#literal_keywords"
		  },
		  {
			"include": "#literal_string"
		  },
		  {
			"include": "#literal_language_variable"
		  }
		]
	  },
	  "literal_number": {
		"patterns": [
		  {
			"name": "invalid.illegal.numeric.hex.sc",
			"match": "(?i)(?:\\B[-+]\\b)0x_?[0-9a-f_]*\\.(\\B|\\b[0-9]+)"
		  },
		  {
			"name": "constant.numeric.hex.sc",
			"match": "\\b0x[0-9A-Fa-f][_0-9A-Fa-f]*"
		  },
		  {
			"name": "constant.numeric.numeric.sc",
			"match": "(?xi)(\\B\\.[0-9][0-9_]*|\\b[0-9][0-9_]*(\\.[0-9][0-9_]*)?)(e[-+]?[0-9][0-9_]*)?[fd]?"
		  },
		  {
			"name": "constant.numeric.escape-unicode.sc",
			"match": "\\'\\\\u[0-9A-Fa-f]{4}\\'"
		  },
		  {
			"name": "constant.numeric.escape-char.sc",
			"match": "\\'\\\\[bfnrt'\\\\]\\'"
		  },
		  {
			"name": "constant.numeric.char.sc",
			"match": "\\'.\\'"
		  }
		]
	  },
	  "literal_language_constant": {
		"patterns": [
		  {
			"name": "constant.language.boolean.true.sc",
			"match": "\\btrue\\b"
		  },
		  {
			"name": "constant.language.boolean.false.sc",
			"match": "\\bfalse\\b"
		  },
		  {
			"name": "constant.language.null.sc",
			"match": "\\bnull\\b"
		  }
		]
	  },
	  "literal_keywords": {
		"patterns": [
		  {
			"name": "storage.modifier.sc",
			"match": "\\b(fun|var|mut|constexpr|operator|reflect|typealias|unsafe|raw|weak|move|ref|own|uninit|await|yield|async|extension|throws|abstract|const|final|internal|native|once|override|private|protected|public|readonly|static|virtual|volatile)\\b"
		  },
		  {
			"name": "storage.modifier.global.sc",
			"match": "\\bimport\\b"
		  },
		  {
			"name": "storage.type.sc",
			"match": "\\b(struct|trait|enum)\\b"
		  },
		  {
			"name": "keyword.control.flow.sc",
			"match": "\\b(return|break|continue)\\b"
		  },
		  {
			"name": "keyword.control.try-catch.sc",
			"match": "\\b(try|catch|finally|throw|assert)\\b"
		  },
		  {
			"name": "keyword.control.loop.sc",
			"match": "\\b(for|while|do)\\b"
		  },
		  {
			"name": "keyword.control.switch.sc",
			"match": "\\b(switch|case|default|fallthrough)\\b"
		  },
		  {
			"name": "keyword.control.if-else.sc",
			"match": "\\b(if|else)\\b"
		  },
		  {
			"name": "keyword.operator.named.sc",
			"match": "\\b(new|is|as)\\b"
		  },
		  {
			"match": "(===?|!==?|<=>?|>=|<|>|\\bis(not)?\\b)",
			"name": "keyword.operator.comparison.sc"
		  },
		  {
			"name": "keyword.operator.assignment.arithmetic.sc",
			"match": "([+*/%-]=)"
		  },
		  {
			"name": "keyword.operator.assignment.sc",
			"match": ":?="
		  },
		  {
			"name": "keyword.operator.increment-decrement.sc",
			"match": "\\-\\-|\\+\\+"
		  },
		  {
			"name": "keyword.operator.arithmetic.sc",
			"match": "\\-|\\+|\\*|\\/|%"
		  },
		  {
			"name": "keyword.operator.logical.sc",
			"match": "(!(?!=)|&&|\\|\\|)"
		  },
		  {
			"name": "keyword.operator.elvis.sc",
			"match": "\\?\\:"
		  },
		  {
			"name": "keyword.operator.trap.sc",
			"match": "\\->"
		  },
		  {
			"name": "keyword.operator.safe-trap.sc",
			"match": "\\?\\->"
		  },
		  {
			"name": "keyword.operator.call.sc",
			"match": "(?<=\\S)\\.(?=\\S)"
		  },
		  {
			"name": "keyword.operator.safe-call.sc",
			"match": "(?<=\\S)\\?\\.(?=\\S)"
		  },
		  {
			"name": "punctuation.terminator.sc",
			"match": ";"
		  }
		]
	  },
	  "literal_language_variable": {
		"patterns": [
		  {
			"name": "variable.language.super.sc",
			"match": "(?<!\\.)\\b(super)\\b"
		  },
		  {
			"name": "variable.language.this.sc",
			"match": "(?!\\.)\\b(this)\\b"
		  },
		  {
			"name": "variable.language.it.sc",
			"match": "(?!\\.)\\b(it)(?=\\.)"
		  }
		]
	  },
	  "literal_string": {
		"patterns": [
		  {
			"name": "string.quoted.double.sc",
			"begin": "\"",
			"beginCaptures": {
			  "0": {
				"name": "punctuation.definition.string.begin.sc"
			  }
			},
			"end": "\"",
			"endCaptures": {
			  "0": {
				"name": "punctuation.definition.string.end.sc"
			  }
			},
			"patterns": [
			  {
				"include": "#escaped_unicode_char"
			  },
			  {
				"include": "#escaped_char"
			  },
			  {
				"include": "#interpolation"
			  }
			]
		  }
		]
	  },
	  "escaped_unicode_char": {
		"patterns": [
		  {
			"name": "constant.character.unicode.sc",
			"match": "\\\\u[0-9A-Fa-f]{4}"
		  }
		]
	  },
	  "escaped_char": {
		"patterns": [
		  {
			"name": "constant.character.escapes.sc",
			"match": "\\\\[bfnrt\"'`$\\\\]"
		  }
		]
	  },
	  "interpolation": {
		"patterns": [
		  {
			"name": "variable.other.interpolated.sc",
			"match": "(?x)\\$(\\{.*?\\}|([A-Za-z_][_\\w]*\\.?)+)"
		  }
		]
	  }
	},
	"scopeName": "source.sc"
}